## 本工程只负责测试以及demo样例编写，不负责anyubao整个产品迭代


### 一般来说，Cpu核心数与线程数是1:1的关系。
    超线程技术后，变为1:2
    但在实际操作中，好像并不会按照确定比例去执行，而且线程可以很多！
    这是因为CPU时间片轮转机制(RR调度)。上下文切换

###  进程和线程
     进程是程序运行，资源分配的最小单位。
     进程包含多个线程，线程之间共享进程的资源。
     线程是CPU调度的最小单位
     
### 并行和并发
    并发一般指的是某单位时间段内执行，可以处理事务的能力
    并行指同一时刻可以处理事务的能力
    
### 高并发编程
    可以充分利用CPU资源， 加快用户的响应时间
    可以使代码模块化，异步处理
    
     
### MQ保证消息不丢失，可以考虑同步刷盘
      同步刷如磁盘，保证消息不丢失
### MQ消息不重复发(保证消息队列消费的幂等性)，业务上保证，比如redis set(天然唯一性)
      其实还是得结合业务来思考，我这里给几个思路：
      比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
      比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。
      比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，
      里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，
      先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，
      然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
      比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，
      重复数据插入只会报错，不会导致数据库中出现脏数据。
### MQ保证一定消费，consumer消费完后再ACK(rocketMQ 中有At least Once即先消费，消费成功后再提交)
### 